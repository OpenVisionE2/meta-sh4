--- a/arch/sh/boards/Kconfig.orig
+++ b/arch/sh/boards/Kconfig
@@ -795,7 +801,79 @@
 	  Select SH_ST_MB903 if configuring for a
 	  STMicroelectronics STi7108M Reference Board.
 
-comment "ST Peripheral Boards"
+config SH_FORTIS_DP2010
+	bool "DP2010: Fortis DP2010 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_DP2010 if configuring for a
+	  Fortis DP2010 board.
+
+#config SH_FORTIS_DP6010
+#	bool "DP6010: Fortis DP6010 board"
+#	depends on CPU_SUBTYPE_STXH205
+#	default n
+#	help
+#	  Select SH_FORTIS_DP6010 if configuring for a
+#	  Fortis DP6010 board.
+
+config SH_FORTIS_DP7000
+	bool "DP7000: Fortis DP7000 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_DP7000 if configuring for a
+	  Fortis DP7000 board.
+
+config SH_FORTIS_DP7001
+	bool "DP7001: Fortis DP7001 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_DP7001 if configuring for a
+	  Fortis DP7001 board.
+
+config SH_FORTIS_DP7050
+	bool "DP7050: Fortis DP7050 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_DP7050 if configuring for a
+	  Fortis DP7050 board.
+
+config SH_FORTIS_EP8000
+	bool "EP8000: Fortis EP8000 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_EP8000 if configuring for a
+	  Fortis EP8000 board.
+
+config SH_FORTIS_EPP8000
+	bool "EPP8000: Fortis EPP8000 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_EPP8000 if configuring for a
+	  Fortis EPP8000 board.
+
+config SH_FORTIS_FX6010
+	bool "FX6010: Fortis FX6010 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_FX6010 if configuring for a
+	  Fortis FX6010 board.
+
+config SH_FORTIS_GPV8000
+	bool "GPV8000: Fortis GPV8000 board"
+	depends on CPU_SUBTYPE_STXH205
+	default n
+	help
+	  Select SH_FORTIS_GPV8000 if configuring for a
+	  Fortis GPV8000 board.
+
+comment "ST Peripheral Boards"
 
 config SH_ST_DB641
 	bool "db641: STEM board with double SMSC LAN9117 Ethernet interface"
--- a/arch/sh/boards/mach-dp2010/Makefile.orig
+++ b/arch/sh/boards/mach-dp2010/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis DP2010 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-dp2010/setup.c.orig
+++ b/arch/sh/boards/mach-dp2010/setup.c
@@ -0,0 +1,527 @@
+/*
+ * arch/sh/boards/mach-dp2010/setup.c
+ *
+ * Modified for Fortis DP2010 board by Audioniek,
+ * based on arch/sh/boards/mach-b2067/setup.c
+ *
+ * Original code:
+ * Copyright (C) 2012 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/stm/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#if defined(INPUT_ET16315)
+#include <linux/et16315.h>
+#endif
+//#include <linux/i2c.h>
+#include <linux/mtd/partitions.h>
+#include <linux/bpa2.h>
+#include <linux/mtd/nand.h>
+#include <linux/stm/nand_devices.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define DP2010_GPIO_POWER_ON_ETH stm_gpio(3, 3)
+#define DP2010_POWER_ON          stm_gpio(3, 7)
+#define KEY_SUSPEND              1 //TODO: get correct value
+
+// DP2010 specific changes
+#define DP2010_HDMI              stm_gpio(2, 5)
+#if defined(INPUT_ET16315)  // for front panel keyboard
+#define ET16315_DIN              stm_gpio(14, 4)
+#define ET16315_DOUT             stm_gpio(14, 5)
+#define ET16315_CLK              stm_gpio(14, 6)
+#define ET16315_STB              stm_gpio(14, 7)
+#endif
+
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+#if 0  // #if defined(CONFIG_BPA2_DIRECTFBOPTIMIZED)
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+	{
+		.name  = "LMI_IO",
+		.start = 0x47600000,
+		.size  = 0x07C00000, /* 124 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	}, 
+	{
+		.name  = "bigphysarea",
+		.start = 0x4F200000,
+		.size  = 0x00E00000, /* 14 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+};
+#else
+/*
+0x40000000 - 0x403fffff - companion 0? (4mb) 
+0x40400000 - 0x404fffff - companion 1? (4mb) 
+0x40800000 - 0x40fd1fff - kernel   (120mb) 
+0x40fd2000 - 0x42dd1fff - bigphys ( 30mb)
+//0x4A000000 - 0x4FBFFFFF - lmi_io  ( 92mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "bigphysarea",
+		.start = 0x40fd2000,
+		.size  = 0x01e00000,  /* 30 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+	{
+		.name  = "LMI_IO",
+		.start = 0x4a000000,
+		.size  = 0x20000000,  /* 92 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	},
+};
+#endif
+
+static void __init dp2010_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Fortis DP2010 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART10: On board DB9 connector CN703
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+		.is_console = 1
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	/*
+	 * UART1: For capturing LIRC message at irw, using uart serial loopback mode
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+	});
+#endif
+
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
+
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+static struct gpio_led dp2010_led[] =
+{
+	{
+		.name = "LED_LOGO",
+		.gpio = stm_gpio(15, 7),
+	}
+};
+ 
+static struct gpio_led_platform_data dp2010_led_data =
+{
+	.num_leds = ARRAY_SIZE(dp2010_led),
+	.leds     = dp2010_led,
+};
+
+static struct platform_device dp2010_leds =
+{
+	.name = "leds-gpio",
+	.id = -1,
+	.dev =
+	{
+		.platform_data = &dp2010_led_data,
+	},
+};
+#endif
+
+#if defined(INPUT_ET16315)
+static struct et16315_key dp2010_front_panel_keys[] =
+{
+	{ 0x00000001, KEY_UP,    "Channel Up" },
+	{ 0x00000002, KEY_DOWN,  "Channel Down" },
+	{ 0x00000004, KEY_RIGHT, "Volume Up" },
+	{ 0x00000008, KEY_LEFT,  "Volume Down" },
+};
+
+static struct et16315_character dp2010_front_panel_characters[] =
+{
+	ET16315_14_SEG_ASCII
+};
+
+static struct platform_device dp2010_front_panel =
+{
+	.name = "et16315",
+	.id = -1,
+	.dev.platform_data = &(struct et16315_platform_data)
+	{
+		.gpio_din         = ET16315_DIN,
+		.gpio_dout        = ET16315_DOUT,
+		.gpio_clk         = ET16315_CLK,
+		.gpio_stb         = ET16315_STB,
+		.digits           = 8,
+		.led              = 1, // all LEDs off, blue on
+
+		.keys_num         = ARRAY_SIZE(dp2010_front_panel_keys),
+		.keys             = dp2010_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness       = 8,
+		.characters_num   = ARRAY_SIZE(dp2010_front_panel_characters),
+		.characters       = dp2010_front_panel_characters
+		.text             = "DP2010",
+	},
+};
+
+static struct gpio_keys_button dp2010_fp_gpio_keys_button =
+{
+	.code = KEY_SUSPEND,
+	.gpio = DP2010_POWER_ON,
+	.desc = "Standby",
+};
+
+static struct platform_device dp2010_fp_gpio_keys =
+{
+	.name          = "gpio-keys",
+	.id            = -1,
+	.num_resources = 0,
+	.dev           =
+	{
+		.platform_data = &(struct gpio_keys_platform_data)
+		{
+			.buttons  = &dp2010_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+	}
+};
+#endif
+
+/* NAND Flash */
+/* The DP2010 main board is equipped with a 256 Mbyte AMD S34ML02G1 NAND flash memory */
+static struct stm_nand_bank_data dp2010_nand_flash =
+{
+	.csn		= 0,
+	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions	= 9,
+	.partitions	= (struct mtd_partition [])
+	{
+		{
+			.name   = "boot",             // mtd0
+			.offset = 0x00000000,
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "kernel",           // mtd1
+			.offset = 0x00400000,         //   4 Mbyte
+			.size   = 0x00400000          //   4 Mbyte
+		},
+		{
+			.name   = "rootfs",           // mtd2 (UBI)
+			.offset = 0x00800000,         //   8 Mbyte
+			.size   = 0x0b600000          // 182 Mbyte
+		},
+		{
+			.name   = "logo",             // mtd3
+			.offset = 0x00180000,         // 1.5 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		},
+		{
+			.name   = "eeprom",           // mtd4
+			.offset = 0x00380000,         // 3.5 Mbyte
+			.size   = 0x00080000          // 512 kbyte
+		},
+		{
+			.name   = "config",           // mtd5 (UBI), seems to be here for compatibility reasons
+			.offset = 0x08000000,         // 128 Mbyte,  as it is somewhere in the middle of rootfs
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "user",             // mtd6
+			.offset = 0x0be00000,         // 190 Mbyte
+			.size   = 0x04000000          //  64 Mbyte
+		},
+		{
+			.name   = "ALL",              // mtd7
+			.offset = 0x00000000,         //   0 Mbyte
+			.size   = MTDPART_SIZ_FULL    // 256 Mbyte
+		},
+		{
+			.name   = "config1",          // mtd8
+			.offset = 0x0fe00000,         // 254 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		}
+	},
+	.timing_spec            = &NAND_TSPEC_SPANSION_S34ML02G1
+};
+
+static int dp2010_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appears
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(DP2010_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(DP2010_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
+	.bus_id = 0,
+	.phy_reset = dp2010_phy_reset,
+	.phy_mask = 0,
+	.probed_phy_irq = ILC_IRQ(25),  /* MDINT */
+};
+
+static struct platform_device *dp2010_devices[] __initdata =
+{
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+	&dp2010_leds,
+#endif
+#if defined(INPUT_ET16315)
+	&dp2010_keys,
+	&dp2010_front_panel,
+ 	&dp2010_fp_gpio_keys,
+#endif
+};
+
+static int __init device_init(void)
+{
+//	int i, j;
+
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(DP2010_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(DP2010_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(DP2010_POWER_ON, "POWER_ON");
+	gpio_direction_output(DP2010_POWER_ON, 0);
+
+	gpio_request(DP2010_HDMI, "HDMI_HPD");  // stm_gpio(2.5)
+	gpio_direction_input(DP2010_HDMI);
+	
+#if 0
+	/* Temporary: try and find the FP LED pio's */
+#define SLEEP 300
+	for (i = 4; i < 16; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+
+			if (j <> 2)
+			{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%2d,%1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config)
+	{
+		.mode          = stxh205_ethernet_mode_mii,
+		.ext_clk       = 1,
+		.phy_bus       = 0,
+		.phy_addr      = -1,
+		.mdio_bus_data = &stmmac_mdio_bus,
+	});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+#if 1  // SATA?
+	stxh205_configure_miphy(&(struct stxh205_miphy_config)
+	{
+		.mode  = SATA_MODE,
+		.iface = UPORT_IF,
+	});
+#endif
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * Assignment of i2c pio's (order equals Fortis stock firmware setup)
+	 *
+	 * SSC1: FE/DEMOD
+	 * Becomes /dev/i2c-0
+	 * i2c addresses: 0x38 (STV6111 tuner), 0x68 (STV0913 demod)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+		.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1
+	});
+	/*
+	 * SSC3: SYS
+	 * Becomes /dev/i2c-1
+	 * i2c addresses: none detected by i2cdetect
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+		.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6
+	});
+	/*
+	 * SSC0: HDMI
+	 * Becomes /dev/i2c-2
+	 * i2c addresses: 0x3a, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 (NAND emulation EEPROM)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(0), &(struct stxh205_ssc_config)
+	{  // HDMI PIO SCDL:6.2, SDA:6.3
+		.routing.ssc0.sclk = stxh205_ssc0_sclk_pio6_2,
+		.routing.ssc0.mtsr = stxh205_ssc0_mtsr_pio6_3
+	});
+	/*
+	 * SSC2: LNBH25PQR LNB power driver
+	 * Becomes /dev/i2c-3
+	 * i2c address: 0x08
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config)
+	{  // LNB PIO SCDL:9.4, SDA:9.5
+		.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+		.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5
+	});
+#if 0
+	/*
+	 * SSC5: ET6226 front panel driver
+	 * Becomes /dev/i2c-4
+	 * i2c addresses: 0x24(CTL), 0x27(KEYS), 0x34(DSP0), 0x35(DSP1), 0x36(DSP2), 0x37(DSP3)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(5), &(struct stxh205_ssc_config)
+	{  // ET6226 PIO SCDL:2.6, SDA:2.7
+	});
+#endif
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	stxh205_configure_lirc(&(struct stxh205_lirc_config)
+	{
+#if defined(CONFIG_LIRC_STM_UHF)
+		.rx_mode       = stxh205_lirc_rx_mode_uhf,
+#else
+		.rx_mode       = stxh205_lirc_rx_mode_ir,
+#endif
+		.tx_enabled    = 0,
+		.tx_od_enabled = 0,
+	});
+#endif  // CONFIG_LIRC_SUPPORT
+
+	stxh205_configure_pwm(&(struct stxh205_pwm_config)
+	{
+		/*
+		 * PWM10 is connected to 12V->1.2V power supply
+		 * for "debug purposes". Enable at your own risk!
+		 */
+		.out10_enabled = 0
+	});
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config)
+	{
+		.emmc                   = 0,
+		.no_mmc_boot_data_error = 1
+	});
+
+	stxh205_configure_nand(&(struct stm_nand_config)
+	{
+		.driver             = stm_nand_flex,
+		.nr_banks           = 1,
+		.banks              = &dp2010_nand_flash,
+		.rbn.flex_connected = 1,
+//		.bch_ecc_cfg        = BCH_ECC_CFG_NOECC
+	});
+
+	return platform_add_devices(dp2010_devices, ARRAY_SIZE(dp2010_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *dp2010_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2067 __initmv =
+{
+	.mv_name = "dp2010",
+	.mv_setup = dp2010_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = dp2010_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int b2067_board_freeze(void)
+{
+	gpio_set_value(DP2010_GPIO_POWER_ON_ETH, 0);
+	return 0;
+}
+
+static int b2067_board_defrost(void)
+{
+	dp2010_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board b2067_hom =
+{
+	.freeze = b2067_board_freeze,
+	.restore = b2067_board_defrost,
+};
+
+static int __init b2067_hom_register(void)
+{
+	return stm_hom_board_register(&b2067_hom);
+}
+
+module_init(b2067_hom_register);
+#endif
+// vim:ts=4
--- a/arch/sh/boards/mach-dp7000/Makefile.orig
+++ b/arch/sh/boards/mach-dp7000/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis DP7000 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-dp7000/setup.c.orig
+++ b/arch/sh/boards/mach-dp7000/setup.c
@@ -0,0 +1,539 @@
+/*
+ * arch/sh/boards/mach-dp7000/setup.c
+ *
+ * Modified for Fortis DP7000 board by Audioniek,
+ * based on arch/sh/boards/mach-b2067/setup.c
+ *
+ * Original code:
+ * Copyright (C) 2012 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/stm/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#if defined(INPUT_ET16315)
+#include <linux/et16315.h>
+#endif
+//#include <linux/i2c.h>
+#include <linux/mtd/partitions.h>
+#include <linux/bpa2.h>
+#include <linux/mtd/nand.h>
+#include <linux/stm/nand_devices.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define DP7000_GPIO_POWER_ON_ETH stm_gpio(3, 3)
+#define DP7000_POWER_ON          stm_gpio(3, 7)
+#define KEY_SUSPEND              1 // TODO: get correct value
+
+// DP7000 specific changes
+#define DP7000_HDMI              stm_gpio(2, 5)
+#if defined(INPUT_ET16315)  // for front panel keyboard
+#define ET16315_DIN              stm_gpio(14, 4)
+#define ET16315_DOUT             stm_gpio(14, 5)
+#define ET16315_CLK              stm_gpio(14, 6)
+#define ET16315_STB              stm_gpio(14, 7)
+#endif
+//#define SMARTCARD1_0             stm_gpio(11, 0)  // From Fortis source
+//#define SMARTCARD1_1             stm_gpio(11, 1)
+
+//#if 0
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+#if 0  // #if defined(CONFIG_BPA2_DIRECTFBOPTIMIZED)
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+	{
+		.name  = "LMI_IO",
+		.start = 0x47600000,
+		.size  = 0x07C00000, /* 124 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	}, 
+	{
+		.name  = "bigphysarea",
+		.start = 0x4F200000,
+		.size  = 0x00E00000, /* 14 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+};
+#else
+/*
+0x40000000 - 0x403fffff - video companion (4mb) 
+0x40400000 - 0x407fffff - audio companion (4mb) 
+0x40800000 - 0x40fd1fff - kernel   (120mb) 
+0x40fd2000 - 0x60fd1fff - bigphys ( 128mb)
+0x4A000000 - 0x4FBFFFFF - lmi_io  ( 30mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "bigphysarea",
+		.start = 0x42600000,
+		.size  = 0x04200000,  /* 66 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+	{
+		.name  = "LMI_IO",
+		.start = 0x40800000,
+		.size  = 0x01e00000,  /* 30 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	},
+};
+#endif
+
+static void __init dp7000_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Fortis DP7000 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART10: On board DB9 connector CN702
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+		.is_console = 1
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	/*
+	 * UART1: For capturing LIRC message at irw, using uart serial loopback mode
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+	});
+#endif
+
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
+
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+static struct gpio_led dp7000_led[] =
+{
+	{
+		.name = "LED_RED",
+		.gpio = stm_gpio(15, 7),  // TODO: find correct PIO number
+	}
+};
+
+static struct gpio_led_platform_data dp7000_led_data =
+{
+	.num_leds = ARRAY_SIZE(dp7000_led),
+	.leds     = dp7000_led,
+};
+
+static struct platform_device dp7000_leds =
+{
+	.name = "leds-gpio",
+	.id = -1,
+	.dev =
+	{
+		.platform_data = &dp7000_led_data,
+	},
+};
+#endif
+
+#if defined(INPUT_ET16315)
+static struct et16315_key dp7000_front_panel_keys[] =
+{
+	{ 0x00000001, KEY_UP,    "Channel Up" },
+	{ 0x00000002, KEY_DOWN,  "Channel Down" },
+	{ 0x00000004, KEY_RIGHT, "Volume Up" },
+	{ 0x00000008, KEY_LEFT,  "Volume Down" },
+};
+
+static struct et16315_character dp7000_front_panel_characters[] =
+{
+	ET16315_14_SEG_ASCII
+};
+
+static struct platform_device dp7000_front_panel =
+{
+	.name = "et16315",
+	.id = -1,
+	.dev.platform_data = &(struct et16315_platform_data)
+	{
+		.gpio_din         = ET16315_DIN,
+		.gpio_dout        = ET16315_DOUT,
+		.gpio_clk         = ET16315_CLK,
+		.gpio_stb         = ET16315_STB,
+		.digits           = 8,
+		.led              = 0, // all LEDs off
+
+		.keys_num         = ARRAY_SIZE(dp7000_front_panel_keys),
+		.keys             = dp7000_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness       = 8,
+		.characters_num   = ARRAY_SIZE(dp7000_front_panel_characters),
+		.characters       = dp7000_front_panel_characters
+		.text             = "DP7000",
+	},
+};
+
+static struct gpio_keys_button dp7000_fp_gpio_keys_button =
+{
+	.code = KEY_SUSPEND,
+	.gpio = DP7000_POWER_ON,
+	.desc = "Standby",
+};
+
+static struct platform_device dp7000_fp_gpio_keys =
+{
+	.name          = "gpio-keys",
+	.id            = -1,
+	.num_resources = 0,
+	.dev           =
+	{
+		.platform_data = &(struct gpio_keys_platform_data)
+		{
+			.buttons  = &dp7000_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+	}
+};
+#endif
+
+/* NAND Flash */
+/* The DP7000 main board is equipped with a 256 Mbyte AMD S34ML02G1 NAND flash memory */
+static struct stm_nand_bank_data dp7000_nand_flash =
+{
+	.csn		= 0,
+	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions	= 9,
+	.partitions	= (struct mtd_partition [])
+	{
+		{
+			.name   = "boot",             // mtd0
+			.offset = 0x00000000,
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "kernel",           // mtd1
+			.offset = 0x00400000,         //   4 Mbyte
+			.size   = 0x00400000          //   4 Mbyte
+		},
+		{
+			.name   = "rootfs",           // mtd2 (UBI)
+			.offset = 0x00800000,         //   8 Mbyte
+			.size   = 0x0b600000          // 182 Mbyte
+		},
+		{
+			.name   = "logo",             // mtd3
+			.offset = 0x00180000,         // 1.5 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		},
+		{
+			.name   = "eeprom",           // mtd4
+			.offset = 0x00380000,         // 3.5 Mbyte
+			.size   = 0x00080000          // 512 kbyte
+		},
+		{
+			.name   = "config",           // mtd5 (UBI), seems to be here for compatibility reasons
+			.offset = 0x08000000,         // 128 Mbyte,  as it is somewhere in the middle of rootfs
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "user",             // mtd6
+			.offset = 0x0be00000,         // 190 Mbyte
+			.size   = 0x04000000          //  64 Mbyte
+		},
+		{
+			.name   = "ALL",              // mtd7
+			.offset = 0x00000000,         //   0 Mbyte
+			.size   = MTDPART_SIZ_FULL    // 256 Mbyte
+		},
+		{
+			.name   = "config1",          // mtd8, this is the config actually usd by the factory firmware
+			.offset = 0x0fe00000,         // 254 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		}
+	},
+	.timing_spec            = &NAND_TSPEC_SPANSION_S34ML02G1
+};
+
+static int dp7000_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appears
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(DP7000_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(DP7000_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
+	.bus_id = 0,
+	.phy_reset = dp7000_phy_reset,
+	.phy_mask = 0,
+	.probed_phy_irq = ILC_IRQ(25),  /* MDINT */
+};
+
+static struct platform_device *dp7000_devices[] __initdata =
+{
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+	&dp7000_leds,
+#endif
+#if defined(INPUT_ET16315)
+	&dp7000_keys,
+	&dp7000_front_panel,
+ 	&dp7000_fp_gpio_keys,
+#endif
+};
+
+static int __init device_init(void)
+{
+#if 0
+	int i, j;
+
+	/* Temporary: try and find the FP LED pio's */
+#define SLEEP 300
+	for (i = 0; i < 16; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+
+			if (! ((i == 3 && j == 1) || (i == 3 && j == 2) || (i == 3 && j == 3) || (i == 3 && j == 7)))
+			{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%2d, %1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(DP7000_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(DP7000_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(DP7000_POWER_ON, "POWER_ON");
+	gpio_direction_output(DP7000_POWER_ON, 0);
+
+	gpio_request(DP7000_HDMI, "HDMI_HPD");  // stm_gpio(2.5)
+	gpio_direction_input(DP7000_HDMI);
+	
+#if 0  // DP7000 has not got an ET6226
+       stm_gpio_direction(stm_gpio(2, 6), STM_GPIO_DIRECTION_BIDIR);
+       stm_gpio_direction(stm_gpio(2, 7), STM_GPIO_DIRECTION_BIDIR);
+#endif
+
+	// jdc1004 '13.07.30 HW request, change to input mode
+	gpio_request(DP7000_HDMI, "HDMI_HPD");
+	gpio_direction_input(DP7000_HDMI);
+
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config)
+	{
+		.mode          = stxh205_ethernet_mode_mii,
+		.ext_clk       = 1,
+		.phy_bus       = 0,
+		.phy_addr      = -1,
+		.mdio_bus_data = &stmmac_mdio_bus,
+	});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+#if 1  // SATA?
+	stxh205_configure_miphy(&(struct stxh205_miphy_config)
+	{
+		.mode  = SATA_MODE,
+		.iface = UPORT_IF,
+	});
+#endif
+	stxh205_configure_sata();
+
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * Assignment of i2c pio's (order equals Fortis stock firmware setup)
+	 *
+	 * SSC1: FE/DEMOD
+	 * Becomes /dev/i2c-0
+	 * i2c addresses: 0x38 (STV6111 tuner), 0x68 (STV0913 demod)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+		.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1
+	});
+	/*
+	 * SSC3: SYS
+	 * Becomes /dev/i2c-1
+	 * i2c addresses: none detected by i2cdetect (CI driver chip?)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+		.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6
+	});
+	/*
+	 * SSC0: HDMI
+	 * Becomes /dev/i2c-2
+	 * i2c addresses: 0x3a, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 (NAND emulation EEPROM)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(0), &(struct stxh205_ssc_config)
+	{  // HDMI PIO SCL:6.2, SDA:6.3
+		.routing.ssc0.sclk = stxh205_ssc0_sclk_pio6_2,
+		.routing.ssc0.mtsr = stxh205_ssc0_mtsr_pio6_3
+	});
+	/*
+	 * SSC2: LNBH25PQR LNB power driver
+	 * Becomes /dev/i2c-3
+	 * i2c address: 0x08
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config)
+	{  // LNB PIO SCL:9.4, SDA:9.5
+		.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+		.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5
+	});
+#if 0
+	/*
+	 * SSC5: ET6226 front panel driver
+	 * Becomes /dev/i2c-4
+	 * i2c addresses: 0x24(CTL), 0x27(KEYS), 0x34(DSP0), 0x35(DSP1), 0x36(DSP2), 0x37(DSP3)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(5), &(struct stxh205_ssc_config)
+	{  // ET6226 PIO SCDL:2.6, SDA:2.7
+		.routing.ssc5.sclk = stxh205_ssc5_sclk_pio2_6,
+		.routing.ssc5.mtsr = stxh205_ssc5_mtsr_pio2_7
+	});
+#endif
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	stxh205_configure_lirc(&(struct stxh205_lirc_config)
+	{
+		.rx_mode       = stxh205_lirc_rx_mode_ir,
+		.tx_enabled    = 0,
+		.tx_od_enabled = 0,
+	});
+#endif  // CONFIG_LIRC_SUPPORT
+
+	stxh205_configure_pwm(&(struct stxh205_pwm_config)
+	{
+		/*
+		 * PWM10 is connected to 12V->1.2V power supply
+		 * for "debug purposes". Enable at your own risk!
+		 */
+		.out10_enabled = 0
+	});
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config)
+	{
+		.emmc                   = 0,
+		.no_mmc_boot_data_error = 1
+	});
+
+	stxh205_configure_nand(&(struct stm_nand_config)
+	{
+		.driver             = stm_nand_flex,
+		.nr_banks           = 1,
+		.banks              = &dp7000_nand_flash,
+		.rbn.flex_connected = 1,
+	});
+
+	return platform_add_devices(dp7000_devices, ARRAY_SIZE(dp7000_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *dp7000_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2067 __initmv =
+{
+	.mv_name = "dp7000",
+	.mv_setup = dp7000_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = dp7000_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int b2067_board_freeze(void)
+{
+	gpio_set_value(DP7000_GPIO_POWER_ON_ETH, 0);
+	return 0;
+}
+
+static int b2067_board_defrost(void)
+{
+	dp7000_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board b2067_hom =
+{
+	.freeze = b2067_board_freeze,
+	.restore = b2067_board_defrost,
+};
+
+static int __init b2067_hom_register(void)
+{
+	return stm_hom_board_register(&b2067_hom);
+}
+
+module_init(b2067_hom_register);
+#endif
+// vim:ts=4
--- a/arch/sh/boards/mach-dp7001/Makefile.orig
+++ b/arch/sh/boards/mach-dp7001/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis DP7001 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-dp7001/setup.c.orig
+++ b/arch/sh/boards/mach-dp7001/setup.c
@@ -0,0 +1,474 @@
+/*
+ * arch/sh/boards/mach-dp7001/setup.c
+ *
+ * Copyright (C) 2012 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+//#include <linux/tm1668.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/stm/nand_devices.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define DP7001_GPIO_FLASH_WP       stm_gpio(6, 2)
+//#ifndef CONFIG_SH_ST_B2067C_BOARD
+//#define DP7001_GPIO_POWER_ON_ETH    stm_gpio(2, 5)
+//#else
+#define DP7001_GPIO_POWER_ON_ETH   stm_gpio(3, 3)
+//#endif
+#define B2067_MII1_TXER            stm_gpio(0, 4)
+#define B2067_POWER_ON             stm_gpio(3, 7)
+
+static void __init dp7001_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "STMicroelectronics B2067 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART_SW: On board DB9 connector CN701
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config)
+	{
+			.hw_flow_control = 0,
+			.is_console = 1,
+	});
+
+#if 0
+	/*
+	 * Header JB4 (with flow control) and JK1 (no flow control)
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config)
+	{
+			.hw_flow_control = 0,
+	});
+#endif
+}
+
+#if 0
+static struct platform_device dp7001_leds =
+{
+	.name = "leds-gpio",
+	.id = -1,
+	.dev.platform_data = &(struct gpio_led_platform_data)
+	{
+		.num_leds = 1,
+		.leds = (struct gpio_led[])
+		{
+			{
+				.name = "RED",
+				.default_trigger = "heartbeat",
+				.gpio = stm_gpio(3, 1),
+			},
+			/*
+			 * Its not clear what's happening here, but it
+			 * appears as if STxH238 has three balls connected
+			 * on the b2067 as:
+			 *   PIO32 - 7108_LMI_RET#
+			 *   PIO33 - LED_GREEN
+			 *   PIO32B - LED_GREEN
+			 * The net effects appers to be a short between
+			 * LMI_RET and LED GREEN which means any attemmpt
+			 * to use the LED causes the system to crash.
+			 *
+			 * This has been fixed on B2067 revB, so if you know
+			 * you're on a rev B uncomment the following block
+			 * and change .num_leds above to 2.
+			 * {
+			 *	.name = "GREEN",
+			 *	.gpio = stm_gpio(3, 3),
+			 * },
+			 */
+		},
+	},
+};
+
+static struct tm1668_key dp7001_front_panel_keys[] =
+{
+	{ 0x00001000, KEY_UP, "Up (SWF2)" },
+	{ 0x00800000, KEY_DOWN, "Down (SWF7)" },
+	{ 0x00008000, KEY_LEFT, "Left (SWF6)" },
+	{ 0x00000010, KEY_RIGHT, "Right (SWF5)" },
+	{ 0x00000080, KEY_OK, "Menu/OK (SWF1)" },
+	{ 0x00100000, KEY_BACK, "Back (SWF4)" },
+	{ 0x80000000, KEY_TV, "DOXTV (SWF9)" },
+};
+
+static struct tm1668_character dp7001_front_panel_characters[] =
+{
+	TM1668_7_SEG_HEX_DIGITS,
+	TM1668_7_SEG_SEGMENTS,
+	TM1668_7_SEG_LETTERS
+};
+
+static struct platform_device dp7001_front_panel =
+{
+	.name = "tm1668",
+	.id = -1,
+	.dev.platform_data = &(struct tm1668_platform_data)
+	{
+		.gpio_dio = stm_gpio(15, 4),
+		.gpio_sclk = stm_gpio(14, 7),
+		.gpio_stb = stm_gpio(14, 4),
+		.config = tm1668_config_6_digits_12_segments,
+
+		.keys_num = ARRAY_SIZE(dp7001_front_panel_keys),
+		.keys = dp7001_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness = 8,
+		.characters_num = ARRAY_SIZE(dp7001_front_panel_characters),
+		.characters = dp7001_front_panel_characters,
+		.text = "H237",
+	},
+};
+
+/* Serial Flash */
+static struct stm_plat_spifsm_data dp7001_serial_flash =
+{
+	.name		= "n25q256",
+	.nr_parts	= 2,
+	.parts = (struct mtd_partition [])
+	{
+		{
+			.name = "Serial Flash 1",
+			.size = 0x00080000,
+			.offset = 0,
+		},
+		{
+			.name = "Serial Flash 2",
+			.size = MTDPART_SIZ_FULL,
+			.offset = MTDPART_OFS_NXTBLK,
+		},
+	},
+	.capabilities =
+	{
+		/* Capabilities may be overriden by SoC configuration */
+		.dual_mode = 1,
+#ifdef CONFIG_SH_ST_B2067A_BOARD
+		/* HOLD and RESET misconnected on Rev A boards*/
+		.quad_mode = 0,
+		.reset_signal = 0,
+#else
+		.quad_mode = 1,
+		.reset_signal = 0,  /* Reset signal can be routed to U4 and U12
+				     * by fitting RM52 (default is DNF)
+				     */
+#endif
+	},
+};
+#endif
+
+/* NAND Flash */
+/* The DP7001 main board is equipped with a 256 Mbyte AMD S34ML02G1 NAND flash memory */
+static struct stm_nand_bank_data dp7001_nand_flash =
+{
+	.csn		= 0,
+	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions	= 9,
+	.partitions	= (struct mtd_partition [])
+	{
+		{
+			.name   = "boot",             // mtd0
+			.offset = 0x00000000,
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "kernel",           // mtd1
+			.offset = 0x00400000,         //   4 Mbyte
+			.size   = 0x00400000          //   4 Mbyte
+		},
+		{
+			.name   = "rootfs",           // mtd2 (UBI)
+			.offset = 0x00800000,         //   8 Mbyte
+			.size   = 0x0b600000          // 182 Mbyte
+		},
+		{
+			.name   = "logo",             // mtd3
+			.offset = 0x00180000,         // 1.5 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		},
+		{
+			.name   = "eeprom",           // mtd4
+			.offset = 0x00380000,         // 3.5 Mbyte
+			.size   = 0x00080000          // 512 kbyte
+		},
+		{
+			.name   = "config",           // mtd5 (UBI), seems to be here for compatibility reasons
+			.offset = 0x08000000,         // 128 Mbyte,  as it is somewhere in the middle of rootfs
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "user",             // mtd6
+			.offset = 0x0be00000,         // 190 Mbyte
+			.size   = 0x04000000          //  64 Mbyte
+		},
+		{
+			.name   = "ALL",              // mtd7
+			.offset = 0x00000000,         //   0 Mbyte
+			.size   = MTDPART_SIZ_FULL    // 256 Mbyte
+		},
+		{
+			.name   = "config1",          // mtd8, this is the config actually usd by the factory firmware
+			.offset = 0x0fe00000,         // 254 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		}
+	},
+	.timing_spec            = &NAND_TSPEC_SPANSION_S34ML02G1
+};
+
+static int dp7001_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appear
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(DP7001_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(DP7001_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
+	.bus_id = 0,
+	.phy_reset = dp7001_phy_reset,
+	.phy_mask = 0,
+	.probed_phy_irq = ILC_IRQ(25), /* MDINT */
+};
+
+static struct platform_device *dp7001_devices[] __initdata =
+{
+//	&dp7001_leds,
+//	&dp7001_front_panel,
+};
+
+static int __init device_init(void)
+{
+#if 1
+	int i, j;
+
+	/* Temporary: try and find the FP LED pio's */
+#define SLEEP 300
+	for (i = 0; i < 16; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+
+			if (! ((i == 2 && j == 6) || (i == 2 && j == 7) || (i == 3 && j == 1) || (i == 3 && j == 2) || (i == 3 && j == 3) || (i == 3 && j == 7)))
+			{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%2d, %1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(DP7001_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(DP7001_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(DP7001_POWER_ON, "POWER_ON");
+	gpio_direction_output(DP7001_POWER_ON, 0);
+
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config)
+	{
+		.mode = stxh205_ethernet_mode_mii,
+		.ext_clk = 1,
+		.phy_bus = 0,
+		.phy_addr = -1,
+		.mdio_bus_data = &stmmac_mdio_bus,
+	});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+	stxh205_configure_miphy(&(struct stxh205_miphy_config)
+	{
+		.mode = SATA_MODE,
+		.iface = UPORT_IF,
+	});
+//	stxh205_configure_sata();
+
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * Assignment of i2c pio's (order equals Fortis stock firmware setup)
+	 *
+	 * SSC1: FE/DEMOD
+	 * Becomes /dev/i2c-0
+	 * i2c addresses: 0x38 (STV6111 tuner), 0x68 (STV0913 demod)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+		.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1,
+	});
+	/*
+	 * SSC3: SYS
+	 * Becomes /dev/i2c-1
+	 * i2c addresses: none detected by i2cdetect (CI driver chip?)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config)
+{
+		.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+		.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6,
+	});
+	 * SSC0: HDMI
+	 * Becomes /dev/i2c-2
+	 * i2c addresses: 0x3a, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 (NAND emulation EEPROM)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(0), &(struct stxh205_ssc_config)
+	{  // HDMI PIO SCL:6.2, SDA:6.3
+		.routing.ssc0.sclk = stxh205_ssc0_sclk_pio6_2,
+		.routing.ssc0.mtsr = stxh205_ssc0_mtsr_pio6_3
+	});
+	/*
+	 * SSC2: LNBH25PQR LNB power driver
+	 * Becomes /dev/i2c-3
+	 * i2c address: 0x08
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config)
+	{  // LNB PIO SCL:9.4, SDA:9.5
+		.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+		.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5
+	});
+#if 1
+	/*
+	 * SSC5: ET6226 front panel driver
+	 * Becomes /dev/i2c-4
+	 * i2c addresses: 0x24(CTL), 0x27(KEYS), 0x34(DSP0), 0x35(DSP1), 0x36(DSP2), 0x37(DSP3)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(5), &(struct stxh205_ssc_config)
+	{  // ET6226 PIO SCL:2.6, SDA:2.7
+		.routing.ssc5.sclk = stxh205_ssc5_sclk_pio2_6,
+		.routing.ssc5.mtsr = stxh205_ssc5_mtsr_pio2_7
+	});
+#endif
+
+	stxh205_configure_lirc(&(struct stxh205_lirc_config)
+	{
+			.rx_mode = stxh205_lirc_rx_mode_ir,
+	});
+
+	stxh205_configure_pwm(&(struct stxh205_pwm_config)
+	{
+		/*
+		 * PWM10 is connected to 12V->1.2V power supply
+		 * for "debug purposes". Enable at your own risk!
+		 */
+		.out10_enabled = 0 });
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config)
+	{
+		.emmc = 0,
+		.no_mmc_boot_data_error = 1,
+	});
+
+	/*
+	 * NAND MTD has no concept of write-protect, so permanently disable WP
+	 */
+	gpio_request(DP7001_GPIO_FLASH_WP, "FLASH_WP");
+	gpio_direction_output(DP7001_GPIO_FLASH_WP, 1);
+
+	stxh205_configure_nand(&(struct stm_nand_config)
+	{
+		.driver             = stm_nand_flex,
+		.nr_banks           = 1,
+		.banks              = &dp7001_nand_flash,
+		.rbn.flex_connected = 1,
+	});
+
+//	stxh205_configure_spifsm(&dp7001_serial_flash);
+
+	return platform_add_devices(dp7001_devices, ARRAY_SIZEdp7001_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *b2067_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2067 __initmv = {
+	.mv_name = "b2067",
+	.mv_setup = b2067_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = b2067_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int b2067_board_freeze(struct stm_wakeup_devices *wkd)
+{
+	if (!wkd->stm_mac0_can_wakeup)
+		gpio_set_value(B2067_GPIO_POWER_ON_ETH, 0);
+	return 0;
+}
+
+static int b2067_board_defrost(struct stm_wakeup_devices *wkd)
+{
+	b2067_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board b2067_hom = {
+	.freeze = b2067_board_freeze,
+	.restore = b2067_board_defrost,
+};
+
+static int __init b2067_hom_register(void)
+{
+	return stm_hom_board_register(&b2067_hom);
+}
+
+module_init(b2067_hom_register);
+#endif
+// vim:ts=4
--- a/arch/sh/boards/mach-dp7050/Makefile.orig
+++ b/arch/sh/boards/mach-dp7050/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis DP7050 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-dp7050/setup.c.orig
+++ b/arch/sh/boards/mach-dp7050/setup.c
@@ -0,0 +1,353 @@
+/*
+ * arch/sh/boards/mach-dp7050/setup.c
+ *
+ * Copyright (C) 2012 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <linux/tm1668.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define B2067_GPIO_FLASH_WP		stm_gpio(6, 2)
+#ifndef CONFIG_SH_ST_B2067C_BOARD
+#define B2067_GPIO_POWER_ON_ETH		stm_gpio(2, 5)
+#else
+#define B2067_GPIO_POWER_ON_ETH		stm_gpio(3, 3)
+#endif
+#define B2067_MII1_TXER			stm_gpio(0, 4)
+#define B2067_POWER_ON			stm_gpio(3, 7)
+
+static void __init b2067_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "STMicroelectronics B2067 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART_SW: On board DB9 connector JM5
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config) {
+			.hw_flow_control = 0,
+			.is_console = 1, });
+
+	/*
+	 * Header JB4 (with flow control) and JK1 (no flow control)
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config) {
+			.hw_flow_control = 0,
+		});
+}
+
+static struct platform_device b2067_leds = {
+	.name = "leds-gpio",
+	.id = -1,
+	.dev.platform_data = &(struct gpio_led_platform_data) {
+		.num_leds = 1,
+		.leds = (struct gpio_led[]) {
+			{
+				.name = "RED",
+				.default_trigger = "heartbeat",
+				.gpio = stm_gpio(3, 1),
+			},
+			/*
+			 * Its not clear what's happening here, but it
+			 * appears as if STxH238 has three balls connected
+			 * on the b2067 as:
+			 *   PIO32 - 7108_LMI_RET#
+			 *   PIO33 - LED_GREEN
+			 *   PIO32B - LED_GREEN
+			 * The net effects appers to be a short between
+			 * LMI_RET and LED GREEN which means any attemmpt
+			 * to use the LED causes the system to crash.
+			 *
+			 * This has been fixed on B2067 revB, so if you know
+			 * you're on a rev B uncomment the following block
+			 * and change .num_leds above to 2.
+			 * {
+			 *	.name = "GREEN",
+			 *	.gpio = stm_gpio(3, 3),
+			 * },
+			 */
+		},
+	},
+};
+
+static struct tm1668_key b2067_front_panel_keys[] = {
+	{ 0x00001000, KEY_UP, "Up (SWF2)" },
+	{ 0x00800000, KEY_DOWN, "Down (SWF7)" },
+	{ 0x00008000, KEY_LEFT, "Left (SWF6)" },
+	{ 0x00000010, KEY_RIGHT, "Right (SWF5)" },
+	{ 0x00000080, KEY_OK, "Menu/OK (SWF1)" },
+	{ 0x00100000, KEY_BACK, "Back (SWF4)" },
+	{ 0x80000000, KEY_TV, "DOXTV (SWF9)" },
+};
+
+static struct tm1668_character b2067_front_panel_characters[] = {
+	TM1668_7_SEG_HEX_DIGITS,
+	TM1668_7_SEG_SEGMENTS,
+	TM1668_7_SEG_LETTERS
+};
+
+static struct platform_device b2067_front_panel = {
+	.name = "tm1668",
+	.id = -1,
+	.dev.platform_data = &(struct tm1668_platform_data) {
+		.gpio_dio = stm_gpio(15, 4),
+		.gpio_sclk = stm_gpio(14, 7),
+		.gpio_stb = stm_gpio(14, 4),
+		.config = tm1668_config_6_digits_12_segments,
+
+		.keys_num = ARRAY_SIZE(b2067_front_panel_keys),
+		.keys = b2067_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness = 8,
+		.characters_num = ARRAY_SIZE(b2067_front_panel_characters),
+		.characters = b2067_front_panel_characters,
+		.text = "H238",
+	},
+};
+
+/* Serial Flash */
+static struct stm_plat_spifsm_data b2067_serial_flash =  {
+	.name		= "n25q256",
+	.nr_parts	= 2,
+	.parts = (struct mtd_partition []) {
+		{
+			.name = "Serial Flash 1",
+			.size = 0x00080000,
+			.offset = 0,
+		}, {
+			.name = "Serial Flash 2",
+			.size = MTDPART_SIZ_FULL,
+			.offset = MTDPART_OFS_NXTBLK,
+		},
+	},
+	.capabilities = {
+		/* Capabilities may be overriden by SoC configuration */
+		.dual_mode = 1,
+#ifdef CONFIG_SH_ST_B2067A_BOARD
+		/* HOLD and RESET misconnected on Rev A boards*/
+		.quad_mode = 0,
+		.reset_signal = 0,
+#else
+		.quad_mode = 1,
+		.reset_signal = 0,  /* Reset signal can be routed to U4 and U12
+				     * by fitting RM52 (default is DNF)
+				     */
+#endif
+	},
+};
+
+/* NAND Flash */
+static struct stm_nand_bank_data b2067_nand_flash = {
+	.csn		= 0,	/* Rev A/B : set JF3 2-3 (EMI_CS0 -> NAND_CS)
+				 * Rev C   : EMI_CS0 hardwired to NAND_CS
+				 */
+	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions	= 2,
+	.partitions	= (struct mtd_partition []) {
+		{
+			.name	= "NAND Flash 1",
+			.offset	= 0,
+			.size	= 0x00800000
+		}, {
+			.name	= "NAND Flash 2",
+			.offset = MTDPART_OFS_NXTBLK,
+			.size	= MTDPART_SIZ_FULL
+		},
+	},
+	.timing_data	=  &(struct stm_nand_timing_data) {
+		.sig_setup	= 50,		/* times in ns */
+		.sig_hold	= 50,
+		.CE_deassert	= 0,
+		.WE_to_RBn	= 100,
+		.wr_on		= 10,
+		.wr_off		= 40,
+		.rd_on		= 10,
+		.rd_off		= 40,
+		.chip_delay	= 30,		/* in us */
+	},
+};
+
+static int b2067_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appear
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(B2067_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(B2067_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus = {
+	.bus_id = 0,
+	.phy_reset = b2067_phy_reset,
+	.phy_mask = 0,
+	.probed_phy_irq = ILC_IRQ(25), /* MDINT */
+};
+
+static struct platform_device *b2067_devices[] __initdata = {
+	&b2067_leds,
+	&b2067_front_panel,
+};
+
+static int __init device_init(void)
+{
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(B2067_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(B2067_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(B2067_POWER_ON, "POWER_ON");
+	gpio_direction_output(B2067_POWER_ON, 0);
+
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config) {
+			.mode = stxh205_ethernet_mode_mii,
+			.ext_clk = 1,
+			.phy_bus = 0,
+			.phy_addr = -1,
+			.mdio_bus_data = &stmmac_mdio_bus,
+		});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+	stxh205_configure_miphy(&(struct stxh205_miphy_config){
+			.mode = SATA_MODE,
+			.iface = UPORT_IF,
+		});
+	stxh205_configure_sata();
+
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * SSC1: FE/DEMO
+	 * U14: LNBH26PQR, STxH238: J_SCL/SDA (internal demod), JB6
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config) {
+			.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+			.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1, });
+	/*
+	 * SSC3: SYS
+	 * UQ1: STV6440, UK2: M24256 (EEPROM), JQ3
+	 * Also JK2 (front panel) on rev A only
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config) {
+			.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+			.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6, });
+	/*
+	 * SSC11: HDMI
+	 * UG1: HDMI2C1 -> HDMI
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(11), NULL);
+
+	stxh205_configure_lirc(&(struct stxh205_lirc_config) {
+#ifdef CONFIG_LIRC_STM_UHF
+			.rx_mode = stxh205_lirc_rx_mode_uhf, });
+#else
+			.rx_mode = stxh205_lirc_rx_mode_ir, });
+#endif
+
+	stxh205_configure_pwm(&(struct stxh205_pwm_config) {
+			/*
+			 * PWM10 is connected to 12V->1.2V power supply
+			 * for "debug purposes". Enable at your own risk!
+			 */
+			.out10_enabled = 0 });
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config) {
+			.emmc = 0,
+			.no_mmc_boot_data_error = 1,
+		});
+	/*
+	 * NAND MTD has no concept of write-protect, so permanently disable WP
+	 */
+	gpio_request(B2067_GPIO_FLASH_WP, "FLASH_WP");
+	gpio_direction_output(B2067_GPIO_FLASH_WP, 1);
+
+	stxh205_configure_nand(&(struct stm_nand_config) {
+			.driver = stm_nand_bch,
+			.nr_banks = 1,
+			.banks = &b2067_nand_flash,
+			.rbn.flex_connected = 1,
+			.bch_ecc_cfg = BCH_ECC_CFG_AUTO});
+
+	stxh205_configure_spifsm(&b2067_serial_flash);
+
+	return platform_add_devices(b2067_devices,
+			ARRAY_SIZE(b2067_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *b2067_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2067 __initmv = {
+	.mv_name = "b2067",
+	.mv_setup = b2067_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = b2067_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int b2067_board_freeze(struct stm_wakeup_devices *wkd)
+{
+	if (!wkd->stm_mac0_can_wakeup)
+		gpio_set_value(B2067_GPIO_POWER_ON_ETH, 0);
+	return 0;
+}
+
+static int b2067_board_defrost(struct stm_wakeup_devices *wkd)
+{
+	b2067_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board b2067_hom = {
+	.freeze = b2067_board_freeze,
+	.restore = b2067_board_defrost,
+};
+
+static int __init b2067_hom_register(void)
+{
+	return stm_hom_board_register(&b2067_hom);
+}
+
+module_init(b2067_hom_register);
+#endif
--- a/arch/sh/boards/mach-ep8000/Makefile.orig
+++ b/arch/sh/boards/mach-ep8000/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis EP8000 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-ep8000/setup.c.orig
+++ b/arch/sh/boards/mach-ep8000/setup.c
@@ -0,0 +1,365 @@
+/*
+ * arch/sh/boards/mach-ep8000/setup.c
+ *
+ * Copyright (C) 2011 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <linux/tm1668.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define B2064_GPIO_FLASH_WP		stm_gpio(6, 2)
+#ifndef CONFIG_SH_ST_B2064C_BOARD
+#define B2064_GPIO_POWER_ON_ETH		stm_gpio(2, 5)
+#else
+#define B2064_GPIO_POWER_ON_ETH		stm_gpio(3, 3)
+#endif
+#define B2064_MII1_TXER			stm_gpio(0, 4)
+#define B2064_POWER_ON			stm_gpio(3, 7)
+
+static void __init b2064_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "STMicroelectronics B2064 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * Socket CN32 DB9-1 connector (no flow control)
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config) {
+			.hw_flow_control = 0,
+			.is_console = 1, });
+	/*
+	 * Socket CN33 DB9-2 connector (no flow control)
+	 * also CN29 as FSK UART (with flow conrtol)
+	 * also JS9 SMART1 (smartcard)
+	 * Note no jumpers to avoid problems with contention.
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config) {
+			.hw_flow_control = 0, });
+}
+
+static struct platform_device b2064_leds = {
+	.name = "leds-gpio",
+	.id = -1,
+	.dev.platform_data = &(struct gpio_led_platform_data) {
+		.num_leds = 1,
+		.leds = (struct gpio_led[]) {
+			{
+				.name = "RED",
+				.default_trigger = "heartbeat",
+				.gpio = stm_gpio(3, 1),
+			},
+			/*
+			 * Its not clear what's happening here, but it
+			 * appears as if STxH239 has three balls connected
+			 * on the b2064 as:
+			 *   PIO32 - 7108_LMI_RET#
+			 *   PIO33 - LED_GREEN
+			 *   PIO32B - LED_GREEN
+			 * The net effects appers to be a short between
+			 * LMI_RET and LED GREEN which means any attemmpt
+			 * to use the LED causes the system to crash.
+			 *
+			 * This has been fixed on B2064 revB, so if you know
+			 * you're on a rev B uncomment the following block
+			 * and change .num_leds above to 2.
+			 * {
+			 *	.name = "GREEN",
+			 *	.gpio = stm_gpio(3, 3),
+			 * },
+			 */
+		},
+	},
+};
+
+static struct tm1668_key b2064_front_panel_keys[] = {
+	{ 0x00001000, KEY_UP, "Up (SWF2)" },
+	{ 0x00800000, KEY_DOWN, "Down (SWF7)" },
+	{ 0x00008000, KEY_LEFT, "Left (SWF6)" },
+	{ 0x00000010, KEY_RIGHT, "Right (SWF5)" },
+	{ 0x00000080, KEY_OK, "Menu/OK (SWF1)" },
+	{ 0x00100000, KEY_BACK, "Back (SWF4)" },
+	{ 0x80000000, KEY_TV, "DOXTV (SWF9)" },
+};
+
+static struct tm1668_character b2064_front_panel_characters[] = {
+	TM1668_7_SEG_HEX_DIGITS,
+	TM1668_7_SEG_SEGMENTS,
+	TM1668_7_SEG_LETTERS
+};
+
+static struct platform_device b2064_front_panel = {
+	.name = "tm1668",
+	.id = -1,
+	.dev.platform_data = &(struct tm1668_platform_data) {
+		.gpio_dio = stm_gpio(15, 4),
+		.gpio_sclk = stm_gpio(14, 7),
+		.gpio_stb = stm_gpio(14, 4),
+		.config = tm1668_config_6_digits_12_segments,
+
+		.keys_num = ARRAY_SIZE(b2064_front_panel_keys),
+		.keys = b2064_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness = 8,
+		.characters_num = ARRAY_SIZE(b2064_front_panel_characters),
+		.characters = b2064_front_panel_characters,
+		.text = "H239",
+	},
+};
+
+static struct gpio_keys_button b2064_fp_gpio_keys_button = {
+	.code = KEY_SUSPEND,
+	.gpio = stm_gpio(15, 7),
+	.desc = "Standby",
+};
+
+static struct platform_device b2064_fp_gpio_keys = {
+        .name = "gpio-keys",
+        .id = -1,
+        .num_resources = 0,
+        .dev = {
+                .platform_data = &(struct gpio_keys_platform_data){
+			.buttons = &b2064_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+        }
+};
+
+/* Serial Flash */
+static struct stm_plat_spifsm_data b2064_serial_flash =  {
+	.name		= "n25q256",
+	.nr_parts	= 2,
+	.parts = (struct mtd_partition []) {
+		{
+			.name = "Serial Flash 1",
+			.size = 0x00080000,
+			.offset = 0,
+		}, {
+			.name = "Serial Flash 2",
+			.size = MTDPART_SIZ_FULL,
+			.offset = MTDPART_OFS_NXTBLK,
+		},
+	},
+	.capabilities = {
+		/* Capabilities may be overriden by SoC configuration */
+		.dual_mode = 1,
+		.quad_mode = 1,
+		.reset_signal = 0, /* Reset signal can be routed to UD16 if RD21
+				    * fitted (default is DNF)
+				    */
+	},
+};
+
+/* NAND Flash */
+static struct stm_nand_bank_data b2064_nand_flash = {
+	.csn		= 0,	/* Rev A/B : set SW4 2-3 (EMI_CS0 -> NAND_CS)
+				 * Rev C   : EMI_CS0 hardwired to NAND_CS
+				 */
+	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions	= 2,
+	.partitions	= (struct mtd_partition []) {
+		{
+			.name	= "NAND Flash 1",
+			.offset	= 0,
+			.size	= 0x00800000
+		}, {
+			.name	= "NAND Flash 2",
+			.offset = MTDPART_OFS_NXTBLK,
+			.size	= MTDPART_SIZ_FULL
+		},
+	},
+	.timing_data	=  &(struct stm_nand_timing_data) {
+		.sig_setup	= 50,		/* times in ns */
+		.sig_hold	= 50,
+		.CE_deassert	= 0,
+		.WE_to_RBn	= 100,
+		.wr_on		= 10,
+		.wr_off		= 40,
+		.rd_on		= 10,
+		.rd_off		= 40,
+		.chip_delay	= 30,		/* in us */
+	},
+};
+
+static int b2064_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appear
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(B2064_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(B2064_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus = {
+	.bus_id = 0,
+	.phy_reset = b2064_phy_reset,
+	.phy_mask = 0,
+	.probed_phy_irq = ILC_IRQ(25), /* MDINT */
+};
+
+static struct platform_device *b2064_devices[] __initdata = {
+	&b2064_leds,
+	&b2064_front_panel,
+	&b2064_fp_gpio_keys,
+};
+
+static int __init device_init(void)
+{
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(B2064_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(B2064_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(B2064_POWER_ON, "POWER_ON");
+	gpio_direction_output(B2064_POWER_ON, 1);
+
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config) {
+			.mode = stxh205_ethernet_mode_mii,
+			.ext_clk = 1,
+			.phy_bus = 0,
+			.phy_addr = -1,
+			.mdio_bus_data = &stmmac_mdio_bus,
+		});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+	stxh205_configure_miphy(&(struct stxh205_miphy_config){
+			.mode = SATA_MODE,
+			.iface = UPORT_IF,
+		});
+	stxh205_configure_sata();
+
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/* SSC1: FE - U14: LNBH26PQR, STxH239: J_SCL/SDA (internal demod), JB6 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config) {
+			.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+			.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1, });
+
+	/* SSC3: SYS - STV6440, EEPROM, Front panel */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config) {
+			.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+			.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6, });
+	/* SSC11: HDMI */
+	stxh205_configure_ssc_i2c(STXH205_SSC(11), NULL);
+
+	/* SSC2: NIM: CN29 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config) {
+			.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+			.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5, });
+
+	stxh205_configure_lirc(&(struct stxh205_lirc_config) {
+#ifdef CONFIG_LIRC_STM_UHF
+			.rx_mode = stxh205_lirc_rx_mode_uhf, });
+#else
+			.rx_mode = stxh205_lirc_rx_mode_ir, });
+#endif
+
+	stxh205_configure_pwm(&(struct stxh205_pwm_config) {
+			/*
+			 * PWM10 is connected to 12V->1.2V power supply
+			 * for "debug purposes". Enable at your own risk!
+			 */
+			.out10_enabled = 0 });
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config) {
+			.emmc = 0,
+			.no_mmc_boot_data_error = 1,
+		});
+
+	/*
+	 * NAND MTD has no concept of write-protect, so permanently disable WP
+	 */
+	gpio_request(B2064_GPIO_FLASH_WP, "FLASH_WP");
+	gpio_direction_output(B2064_GPIO_FLASH_WP, 1);
+
+	stxh205_configure_nand(&(struct stm_nand_config) {
+			.driver = stm_nand_bch,
+			.nr_banks = 1,
+			.banks = &b2064_nand_flash,
+			.rbn.flex_connected = 1,
+			.bch_ecc_cfg = BCH_ECC_CFG_AUTO});
+
+	stxh205_configure_spifsm(&b2064_serial_flash);
+
+	return platform_add_devices(b2064_devices,
+			ARRAY_SIZE(b2064_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *b2064_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2064 __initmv = {
+	.mv_name = "b2064",
+	.mv_setup = b2064_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = b2064_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int b2064_board_freeze(struct stm_wakeup_devices *wkd)
+{
+	if (!wkd->stm_mac0_can_wakeup)
+		gpio_set_value(B2064_GPIO_POWER_ON_ETH, 0);
+	return 0;
+}
+
+static int b2064_board_defrost(struct stm_wakeup_devices *wkd)
+{
+	b2064_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board b2064_hom = {
+	.freeze = b2064_board_freeze,
+	.restore = b2064_board_defrost,
+};
+
+static int __init b2064_hom_register(void)
+{
+	return stm_hom_board_register(&b2064_hom);
+}
+
+module_init(b2064_hom_register);
+#endif
+
--- a/arch/sh/boards/mach-epp8000/Makefile.orig
+++ b/arch/sh/boards/mach-epp8000/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis EPP8000 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-epp8000/setup.c.orig
+++ b/arch/sh/boards/mach-epp8000/setup.c
@@ -0,0 +1,365 @@
+/*
+ * arch/sh/boards/mach-epp8000/setup.c
+ *
+ * Copyright (C) 2011 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <linux/tm1668.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define B2064_GPIO_FLASH_WP		stm_gpio(6, 2)
+#ifndef CONFIG_SH_ST_B2064C_BOARD
+#define B2064_GPIO_POWER_ON_ETH		stm_gpio(2, 5)
+#else
+#define B2064_GPIO_POWER_ON_ETH		stm_gpio(3, 3)
+#endif
+#define B2064_MII1_TXER			stm_gpio(0, 4)
+#define B2064_POWER_ON			stm_gpio(3, 7)
+
+static void __init b2064_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "STMicroelectronics B2064 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * Socket CN32 DB9-1 connector (no flow control)
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config) {
+			.hw_flow_control = 0,
+			.is_console = 1, });
+	/*
+	 * Socket CN33 DB9-2 connector (no flow control)
+	 * also CN29 as FSK UART (with flow conrtol)
+	 * also JS9 SMART1 (smartcard)
+	 * Note no jumpers to avoid problems with contention.
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config) {
+			.hw_flow_control = 0, });
+}
+
+static struct platform_device b2064_leds = {
+	.name = "leds-gpio",
+	.id = -1,
+	.dev.platform_data = &(struct gpio_led_platform_data) {
+		.num_leds = 1,
+		.leds = (struct gpio_led[]) {
+			{
+				.name = "RED",
+				.default_trigger = "heartbeat",
+				.gpio = stm_gpio(3, 1),
+			},
+			/*
+			 * Its not clear what's happening here, but it
+			 * appears as if STxH239 has three balls connected
+			 * on the b2064 as:
+			 *   PIO32 - 7108_LMI_RET#
+			 *   PIO33 - LED_GREEN
+			 *   PIO32B - LED_GREEN
+			 * The net effects appers to be a short between
+			 * LMI_RET and LED GREEN which means any attemmpt
+			 * to use the LED causes the system to crash.
+			 *
+			 * This has been fixed on B2064 revB, so if you know
+			 * you're on a rev B uncomment the following block
+			 * and change .num_leds above to 2.
+			 * {
+			 *	.name = "GREEN",
+			 *	.gpio = stm_gpio(3, 3),
+			 * },
+			 */
+		},
+	},
+};
+
+static struct tm1668_key b2064_front_panel_keys[] = {
+	{ 0x00001000, KEY_UP, "Up (SWF2)" },
+	{ 0x00800000, KEY_DOWN, "Down (SWF7)" },
+	{ 0x00008000, KEY_LEFT, "Left (SWF6)" },
+	{ 0x00000010, KEY_RIGHT, "Right (SWF5)" },
+	{ 0x00000080, KEY_OK, "Menu/OK (SWF1)" },
+	{ 0x00100000, KEY_BACK, "Back (SWF4)" },
+	{ 0x80000000, KEY_TV, "DOXTV (SWF9)" },
+};
+
+static struct tm1668_character b2064_front_panel_characters[] = {
+	TM1668_7_SEG_HEX_DIGITS,
+	TM1668_7_SEG_SEGMENTS,
+	TM1668_7_SEG_LETTERS
+};
+
+static struct platform_device b2064_front_panel = {
+	.name = "tm1668",
+	.id = -1,
+	.dev.platform_data = &(struct tm1668_platform_data) {
+		.gpio_dio = stm_gpio(15, 4),
+		.gpio_sclk = stm_gpio(14, 7),
+		.gpio_stb = stm_gpio(14, 4),
+		.config = tm1668_config_6_digits_12_segments,
+
+		.keys_num = ARRAY_SIZE(b2064_front_panel_keys),
+		.keys = b2064_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness = 8,
+		.characters_num = ARRAY_SIZE(b2064_front_panel_characters),
+		.characters = b2064_front_panel_characters,
+		.text = "H239",
+	},
+};
+
+static struct gpio_keys_button b2064_fp_gpio_keys_button = {
+	.code = KEY_SUSPEND,
+	.gpio = stm_gpio(15, 7),
+	.desc = "Standby",
+};
+
+static struct platform_device b2064_fp_gpio_keys = {
+        .name = "gpio-keys",
+        .id = -1,
+        .num_resources = 0,
+        .dev = {
+                .platform_data = &(struct gpio_keys_platform_data){
+			.buttons = &b2064_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+        }
+};
+
+/* Serial Flash */
+static struct stm_plat_spifsm_data b2064_serial_flash =  {
+	.name		= "n25q256",
+	.nr_parts	= 2,
+	.parts = (struct mtd_partition []) {
+		{
+			.name = "Serial Flash 1",
+			.size = 0x00080000,
+			.offset = 0,
+		}, {
+			.name = "Serial Flash 2",
+			.size = MTDPART_SIZ_FULL,
+			.offset = MTDPART_OFS_NXTBLK,
+		},
+	},
+	.capabilities = {
+		/* Capabilities may be overriden by SoC configuration */
+		.dual_mode = 1,
+		.quad_mode = 1,
+		.reset_signal = 0, /* Reset signal can be routed to UD16 if RD21
+				    * fitted (default is DNF)
+				    */
+	},
+};
+
+/* NAND Flash */
+static struct stm_nand_bank_data b2064_nand_flash = {
+	.csn		= 0,	/* Rev A/B : set SW4 2-3 (EMI_CS0 -> NAND_CS)
+				 * Rev C   : EMI_CS0 hardwired to NAND_CS
+				 */
+	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions	= 2,
+	.partitions	= (struct mtd_partition []) {
+		{
+			.name	= "NAND Flash 1",
+			.offset	= 0,
+			.size	= 0x00800000
+		}, {
+			.name	= "NAND Flash 2",
+			.offset = MTDPART_OFS_NXTBLK,
+			.size	= MTDPART_SIZ_FULL
+		},
+	},
+	.timing_data	=  &(struct stm_nand_timing_data) {
+		.sig_setup	= 50,		/* times in ns */
+		.sig_hold	= 50,
+		.CE_deassert	= 0,
+		.WE_to_RBn	= 100,
+		.wr_on		= 10,
+		.wr_off		= 40,
+		.rd_on		= 10,
+		.rd_off		= 40,
+		.chip_delay	= 30,		/* in us */
+	},
+};
+
+static int b2064_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appear
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(B2064_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(B2064_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus = {
+	.bus_id = 0,
+	.phy_reset = b2064_phy_reset,
+	.phy_mask = 0,
+	.probed_phy_irq = ILC_IRQ(25), /* MDINT */
+};
+
+static struct platform_device *b2064_devices[] __initdata = {
+	&b2064_leds,
+	&b2064_front_panel,
+	&b2064_fp_gpio_keys,
+};
+
+static int __init device_init(void)
+{
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(B2064_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(B2064_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(B2064_POWER_ON, "POWER_ON");
+	gpio_direction_output(B2064_POWER_ON, 1);
+
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config) {
+			.mode = stxh205_ethernet_mode_mii,
+			.ext_clk = 1,
+			.phy_bus = 0,
+			.phy_addr = -1,
+			.mdio_bus_data = &stmmac_mdio_bus,
+		});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+	stxh205_configure_miphy(&(struct stxh205_miphy_config){
+			.mode = SATA_MODE,
+			.iface = UPORT_IF,
+		});
+	stxh205_configure_sata();
+
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/* SSC1: FE - U14: LNBH26PQR, STxH239: J_SCL/SDA (internal demod), JB6 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config) {
+			.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+			.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1, });
+
+	/* SSC3: SYS - STV6440, EEPROM, Front panel */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config) {
+			.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+			.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6, });
+	/* SSC11: HDMI */
+	stxh205_configure_ssc_i2c(STXH205_SSC(11), NULL);
+
+	/* SSC2: NIM: CN29 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config) {
+			.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+			.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5, });
+
+	stxh205_configure_lirc(&(struct stxh205_lirc_config) {
+#ifdef CONFIG_LIRC_STM_UHF
+			.rx_mode = stxh205_lirc_rx_mode_uhf, });
+#else
+			.rx_mode = stxh205_lirc_rx_mode_ir, });
+#endif
+
+	stxh205_configure_pwm(&(struct stxh205_pwm_config) {
+			/*
+			 * PWM10 is connected to 12V->1.2V power supply
+			 * for "debug purposes". Enable at your own risk!
+			 */
+			.out10_enabled = 0 });
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config) {
+			.emmc = 0,
+			.no_mmc_boot_data_error = 1,
+		});
+
+	/*
+	 * NAND MTD has no concept of write-protect, so permanently disable WP
+	 */
+	gpio_request(B2064_GPIO_FLASH_WP, "FLASH_WP");
+	gpio_direction_output(B2064_GPIO_FLASH_WP, 1);
+
+	stxh205_configure_nand(&(struct stm_nand_config) {
+			.driver = stm_nand_bch,
+			.nr_banks = 1,
+			.banks = &b2064_nand_flash,
+			.rbn.flex_connected = 1,
+			.bch_ecc_cfg = BCH_ECC_CFG_AUTO});
+
+	stxh205_configure_spifsm(&b2064_serial_flash);
+
+	return platform_add_devices(b2064_devices,
+			ARRAY_SIZE(b2064_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *b2064_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2064 __initmv = {
+	.mv_name = "b2064",
+	.mv_setup = b2064_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = b2064_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int b2064_board_freeze(struct stm_wakeup_devices *wkd)
+{
+	if (!wkd->stm_mac0_can_wakeup)
+		gpio_set_value(B2064_GPIO_POWER_ON_ETH, 0);
+	return 0;
+}
+
+static int b2064_board_defrost(struct stm_wakeup_devices *wkd)
+{
+	b2064_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board b2064_hom = {
+	.freeze = b2064_board_freeze,
+	.restore = b2064_board_defrost,
+};
+
+static int __init b2064_hom_register(void)
+{
+	return stm_hom_board_register(&b2064_hom);
+}
+
+module_init(b2064_hom_register);
+#endif
+// vim:ts=4
--- a/arch/sh/boards/mach-fx6010/Makefile.orig
+++ b/arch/sh/boards/mach-fx6010/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis DP6010 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-fx6010/setup.c.orig
+++ b/arch/sh/boards/mach-fx6010/setup.c
@@ -0,0 +1,527 @@
+/*
+ * arch/sh/boards/mach-fx6010/setup.c
+ *
+ * Modified for Fortis DP6010 board by Audioniek,
+ * based on arch/sh/boards/mach-b2067/setup.c
+ *
+ * Original code:
+ * Copyright (C) 2012 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/stm/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#if defined(INPUT_ET6226)
+#include <linux/et6226.h>
+#include <linux/i2c.h>
+#endif
+#include <linux/mtd/partitions.h>
+#include <linux/bpa2.h>
+#include <linux/mtd/nand.h>
+#include <linux/stm/nand_devices.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+#define FX6010_GPIO_POWER_ON_ETH stm_gpio(3, 3)
+#define FX6010_POWER_ON          stm_gpio(3, 7)
+#define KEY_SUSPEND              1 //TODO: get correct value
+
+//DP6010 specific changes
+#define FX6010_HDMI              stm_gpio(2, 5)
+#if defined(INPUT_ET6226)
+#define ET6226_I2C_SCL           stm_gpio(2, 6)
+#define ET6226_I2C_SDA           stm_gpio(2, 7)
+#endif
+
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+#if 0  // #if defined(CONFIG_BPA2_DIRECTFBOPTIMIZED)
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+	{
+		.name  = "LMI_IO",
+		.start = 0x47600000,
+		.size  = 0x07C00000, /* 124 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	}, 
+	{
+		.name  = "bigphysarea",
+		.start = 0x4F200000,
+		.size  = 0x00E00000, /* 14 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+};
+#else
+/*
+0x40000000 - 0x403fffff - companion 0? (4mb) 
+0x40400000 - 0x404fffff - companion 1? (4mb) 
+0x40800000 - 0x40fd1fff - kernel   (120mb) 
+0x40fd2000 - 0x42dd1fff - bigphys ( 30mb)
+//0x4A000000 - 0x4FBFFFFF - lmi_io  ( 92mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "bigphysarea",
+		.start = 0x40fd2000,
+		.size  = 0x01e00000,  /* 30 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+	{
+		.name  = "LMI_IO",
+		.start = 0x4a000000,
+		.size  = 0x20000000,  /* 92 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	},
+};
+#endif
+
+static void __init fx6010_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Fortis DP6010 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART10: On board DB9 connector CN701
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+		.is_console = 1
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	/*
+	 * UART1: For capturing LIRC message at irw, using uart serial loopback mode
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+	});
+#endif
+
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
+
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+static struct gpio_led fx6010_led[] =
+{
+	{
+		.name = "LED_GREEN",
+		.gpio = stm_gpio(13, 2)
+	},
+	{
+		.name = "LED_LOGO",
+		.gpio = stm_gpio(15, 7)
+	}
+};
+
+static struct gpio_led_platform_data fx6010_led_data =
+{
+	.num_leds	= ARRAY_SIZE(fx6010_led),
+	.leds		= fx6010_led
+};
+
+static struct platform_device fx6010_leds =
+{
+	.name = "leds-gpio",
+	.id = -1,
+	.dev =
+	{
+		.platform_data = &fx6010_led_data,
+	}
+};
+#endif
+
+#if defined(INPUT_ET6226)
+static struct et6226 key fx6010 front_panel_keys[] =
+{
+	{ 0x00000001, KEY_UP,    "Channel Up" },
+	{ 0x00000002, KEY_DOWN,  "Channel Down" }
+};
+
+static struct et6226_character fx6010_front_panel_characters[] =
+{
+	ET6226_7_SEG_ASCII
+};
+
+static struct platform_device fx6010_front_panel =
+{
+	.name = "et6226",
+	.id   = -1,
+	.dev.platform_data = &(struct et6226_platform_data)
+	{
+		.gpio_scl         = ET6226_I2C_SCL,
+		.gpio_sda         = ET6226_I2C_SDA,
+		.digits           = 4,
+
+		.keys_num         = ARRAY_SIZE(fx6010_front_panel_keys),
+		.keys             = fx6010_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+		.brightness       = 8,
+		.characters_num   = ARRAY_SIZE(fx6010_front_panel_characters),
+		.characters       = fx6010_front_panel_characters
+		.text             = "6010",
+	},
+};
+
+static struct gpio_keys_button fx6010_fp_gpio_keys_button =
+{
+	.code = KEY_SUSPEND,
+	.gpio = FX6010_POWER_ON,
+	.desc = "Standby",
+};
+
+static struct platform_device fx6010_fp_gpio_keys =
+{
+	.name          = "gpio-keys",
+	.id            = -1,
+	.num_resources = 0,
+	.dev           =
+	{
+		.platform_data = &(struct gpio_keys_platform_data)
+		{
+			.buttons  = &fx6010_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+	}
+};
+#endif
+
+/* NAND Flash */
+/* The DP6010 main board is equipped with a 256 Mbyte AMD S34ML02G1 NAND flash memory */
+static struct stm_nand_bank_data fx6010_nand_flash =
+{
+	.csn		= 0,
+	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions	= 9,
+	.partitions	= (struct mtd_partition [])
+	{
+		{
+			.name   = "boot",             // mtd0
+			.offset = 0x00000000,
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "kernel",           // mtd1
+			.offset = 0x00400000,         //   4 Mbyte
+			.size   = 0x00400000          //   4 Mbyte
+		},
+		{
+			.name   = "rootfs",           // mtd2 (UBI)
+			.offset = 0x00800000,         //   8 Mbyte
+			.size   = 0x0b600000          // 182 Mbyte
+		},
+		{
+			.name   = "logo",             // mtd3
+			.offset = 0x00180000,         // 1.5 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		},
+		{
+			.name   = "eeprom",           // mtd4
+			.offset = 0x00380000,         // 3.5 Mbyte
+			.size   = 0x00080000          // 512 kbyte
+		},
+		{
+			.name   = "config",           // mtd5 (UBI), seems to be here for compatibility reasons
+			.offset = 0x08000000,         // 128 Mbyte,  as it is somewhere in the middle of rootfs
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "user",             // mtd6
+			.offset = 0x0be00000,         // 190 Mbyte
+			.size   = 0x04000000          //  64 Mbyte
+		},
+		{
+			.name   = "ALL",              // mtd7
+			.offset = 0x00000000,         //   0 Mbyte
+			.size   = MTDPART_SIZ_FULL    // 256 Mbyte
+		},
+		{
+			.name   = "config1",          // mtd8       This is the config actually used
+			.offset = 0x0fe00000,         // 254 Mbyte  by the factory firmware
+			.size   = 0x00200000          //   2 Mbyte
+		}
+	},
+	.timing_spec            = &NAND_TSPEC_SPANSION_S34ML02G1
+};
+
+static int fx6010_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appears
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(FX6010_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(FX6010_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
+	.bus_id         = 0,
+	.phy_reset      = fx6010_phy_reset,
+	.phy_mask       = 0,
+	.probed_phy_irq = ILC_IRQ(25),  /* MDINT */
+};
+
+static struct platform_device *fx6010_devices[] __initdata =
+{
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+	&fx6010_leds,
+#endif
+#if defined(INPUT_ET6226)
+	&fx6010_keys,
+	&fx6010_front_panel,
+ 	&fx6010_fp_gpio_keys,
+#endif
+};
+
+static int __init device_init(void)
+{
+	int i, j;
+
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(FX6010_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(FX6010_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(FX6010_POWER_ON, "POWER_ON");
+	gpio_direction_output(FX6010_POWER_ON, 0);
+
+	gpio_request(FX6010_HDMI, "HDMI_HPD");  // stm_gpio(2.5)
+	gpio_direction_input(FX6010_HDMI);
+	
+#if 1
+	/* Temporary: try and find the FP LED pio's */
+#define SLEEP 300
+	for (i = 4; i < 16; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+
+			if (j != 2)
+			{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%2d,%1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config)
+	{
+		.mode          = stxh205_ethernet_mode_mii,
+		.ext_clk       = 1,
+		.phy_bus       = 0,
+		.phy_addr      = -1,
+		.mdio_bus_data = &stmmac_mdio_bus,
+	});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+#if 1  // SATA?
+	stxh205_configure_miphy(&(struct stxh205_miphy_config)
+	{
+		.mode = SATA_MODE,
+		.iface = UPORT_IF,
+	});
+#endif
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * Assignment of i2c pio's (order equals Fortis stock firmware setup)
+	 *
+	 * SSC1: FE/DEMOD
+	 * Becomes /dev/i2c-0
+	 * i2c addresses: 0x38 (STV6111 tuner), 0x68 (STV0913 demod)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+		.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1
+	});
+	/*
+	 * SSC3: SYS
+	 * Becomes /dev/i2c-1
+	 * i2c addresses: none detected by i2cdetect
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+		.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6
+	});
+	/*
+	 * SSC0: HDMI
+	 * Becomes /dev/i2c-2
+	 * i2c addresses: 0x3a, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 (NAND emulation EEPROM)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(0), &(struct stxh205_ssc_config)
+	{  // HDMI PIO SCDL:6.2, SDA:6.3
+		.routing.ssc0.sclk = stxh205_ssc0_sclk_pio6_2,
+		.routing.ssc0.mtsr = stxh205_ssc0_mtsr_pio6_3
+	});
+	/*
+	 * SSC2: LNBH25PQR LNB power driver
+	 * Becomes /dev/i2c-3
+	 * i2c address: 0x08
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config)
+	{ // LNB PIO SCDL:9.4, SDA:9.5
+
+		.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+		.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5
+	});
+#if defined(INPUT_ET6226)
+	/*
+	 * SSC5: ET6226 front panel driver
+	 * Becomes /dev/i2c-4
+	 * i2c addresses: 0x24(CTL), 0x27(KEYS), 0x34(DSP0), 0x35(DSP1), 0x36(DSP2), 0x37(DSP3)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(5), &(struct stxh205_ssc_config)
+	{  // ET6226 PIO SCDL:2.6, SDA:2.7
+//TODO:		.routing.ssc3.sclk = stxh205_ssc2_sclk_pio2_6,
+//		.routing.ssc3.mtsr = stxh205_ssc2_mtsr_pio2_7
+	});
+#endif
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	stxh205_configure_lirc(&(struct stxh205_lirc_config)
+	{
+#if defined(CONFIG_LIRC_STM_UHF)
+		.rx_mode       = stxh205_lirc_rx_mode_uhf,
+#else
+		.rx_mode       = stxh205_lirc_rx_mode_ir,
+#endif
+		.tx_enabled    = 0,
+		.tx_od_enabled = 0,
+	});
+#endif  // CONFIG_LIRC_SUPPORT
+
+	stxh205_configure_pwm(&(struct stxh205_pwm_config)
+	{
+		/*
+		 * PWM10 is connected to 12V->1.2V power supply
+		 * for "debug purposes". Enable at your own risk!
+		 */
+		.out10_enabled = 0
+	});
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config)
+	{
+		.emmc                   = 0,
+		.no_mmc_boot_data_error = 1
+	});
+
+	stxh205_configure_nand(&(struct stm_nand_config)
+	{
+		.driver             = stm_nand_flex,
+		.nr_banks           = 1,
+		.banks              = &fx6010_nand_flash,
+		.rbn.flex_connected = 1,
+//		.bch_ecc_cfg        = BCH_ECC_CFG_NOECC
+	});
+
+	return platform_add_devices(fx6010_devices, ARRAY_SIZE(fx6010_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *fx6010_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_b2067 __initmv =
+{
+	.mv_name       = "fx6010",
+	.mv_setup      = fx6010_setup,
+	.mv_nr_irqs    = NR_IRQS,
+	.mv_ioport_map = fx6010_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int b2067_board_freeze(void)
+{
+	gpio_set_value(FX6010_GPIO_POWER_ON_ETH, 0);
+	return 0;
+}
+
+static int b2067_board_defrost(void)
+{
+	fx6010_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board b2067_hom =
+{
+	.freeze = b2067_board_freeze,
+	.restore = b2067_board_defrost,
+};
+
+static int __init b2067_hom_register(void)
+{
+	return stm_hom_board_register(&b2067_hom);
+}
+
+module_init(b2067_hom_register);
+#endif
+// vim:ts=4
--- a/arch/sh/boards/mach-gpv8000/Makefile.orig
+++ b/arch/sh/boards/mach-gpv8000/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Fortis GPV8000 board
+#
+
+obj-y := setup.o
--- a/arch/sh/boards/mach-gpv8000/setup.c.orig
+++ b/arch/sh/boards/mach-gpv8000/setup.c
@@ -0,0 +1,525 @@
+/*
+ * arch/sh/boards/mach-gpv8000/setup.c
+ *
+ * Modified for Fortis GPV8000 board by Audioniek,
+ * based on arch/sh/boards/mach-b2067/setup.c
+ *
+ * Original code:
+ * Copyright (C) 2012 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#if defined(INPUT_ET16315)
+#include <linux/et16315.h>
+#endif
+#include <linux/mtd/partitions.h>
+#include <linux/bpa2.h>
+#include <linux/mtd/nand.h>
+#include <linux/stm/nand_devices.h>
+#include <linux/stm/platform.h>
+#include <linux/stm/stxh205.h>
+#include <linux/stm/sysconf.h>
+#include <asm/irq-ilc.h>
+
+//#define GPV8000_GPIO_FLASH_WP     stm_gpio(6, 2)
+#define GPV8000_GPIO_POWER_ON_ETH stm_gpio(3, 3)
+//#define GPV8000_MII1_TXER         stm_gpio(0, 4)
+#define GPV8000_POWER_ON          stm_gpio(3, 7)
+
+// GPV8000 specific changes
+#define GPV8000_HDMI             stm_gpio(2, 5)
+#if defined(INPUT_ET16315)  // for front panel keyboard
+#define ET16315_DIN              stm_gpio(14, 4)
+#define ET16315_DOUT             stm_gpio(14, 5)
+#define ET16315_CLK              stm_gpio(14, 6)
+#define ET16315_STB              stm_gpio(14, 7)
+#endif
+
+#if 0  // #if defined(CONFIG_BPA2_DIRECTFBOPTIMIZED)
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+	{
+		.name  = "LMI_IO",
+		.start = 0x47600000,
+		.size  = 0x07C00000, /* 124 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	}, 
+	{
+		.name  = "bigphysarea",
+		.start = 0x4F200000,
+		.size  = 0x00E00000, /* 14 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+};
+#else
+/*
+0x40000000 - 0x403fffff - companion 0? (4mb) 
+0x40400000 - 0x404fffff - companion 1? (4mb) 
+0x40800000 - 0x40fd1fff - kernel   (120mb) 
+0x40fd2000 - 0x42dd1fff - bigphys ( 30mb)
+//0x4A000000 - 0x4FBFFFFF - lmi_io  ( 92mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "bigphysarea",
+		.start = 0x40fd2000,
+		.size  = 0x01e00000,  /* 30 Mb */
+		.flags = 0,
+		.aka   = NULL
+	},
+	{
+		.name  = "LMI_IO",
+		.start = 0x4a000000,
+		.size  = 0x20000000,  /* 92 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	},
+};
+#endif
+
+static void __init gpv8000_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Fortis GPV8000 board initialisation\n");
+
+	stxh205_early_device_init();
+
+	/*
+	 * UART10: On board DB9 connector CN703
+	 */
+	stxh205_configure_asc(STXH205_ASC(10), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+		.is_console = 1
+	});
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	/*
+	 * UART1: For capturing LIRC message at irw, using uart serial loopback mode
+	 */
+	stxh205_configure_asc(STXH205_ASC(1), &(struct stxh205_asc_config)
+	{
+		.hw_flow_control = 0,
+	});
+#endif
+
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
+
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+static struct gpio_led gpv8000_led[] =
+{
+	{
+		.name = "LED_LOGO",
+		.gpio = stm_gpio(15, 7),
+	}
+};
+ static struct gpio_led_platform_data gpv8000_led_data =
+{
+	.num_leds = ARRAY_SIZE(gpv8000_led),
+	.leds     = gpv8000_led,
+};
+
+static struct platform_device gpv8000_leds =
+{
+	.name = "leds-gpio",
+	.id = -1,
+	.dev =
+	{
+		.platform_data = &gpv8000_led_data,
+	},
+};
+#endif
+
+#if defined(INPUT_ET16315)
+static struct et16315_key gpv8000_front_panel_keys[] =
+{
+	{ 0x00000001, KEY_UP,    "Channel Up" },
+	{ 0x00000002, KEY_DOWN,  "Channel Down" },
+	{ 0x00000004, KEY_RIGHT, "Volume Up" },
+	{ 0x00000008, KEY_LEFT,  "Volume Down" },
+};
+
+static struct et16315_character gpv8000_front_panel_characters[] =
+{
+	ET16315_14_SEG_ASCII
+};
+
+static struct platform_device gpv8000_front_panel =
+{
+	.name = "et16315",
+	.id = -1,
+	.dev.platform_data = &(struct et16315_platform_data)
+	{
+		.gpio_din         = ET16315_DIN,
+		.gpio_dout        = ET16315_DOUT,
+		.gpio_clk         = ET16315_CLK,
+		.gpio_stb         = ET16315_STB,
+		.digits           = 8,
+		.led              = 0, // all LEDs off
+
+		.keys_num         = ARRAY_SIZE(gpv8000_front_panel_keys),
+		.keys             = gpv8000_front_panel_keys,
+		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
+
+ 		.brightness       = 8,
+ 		.characters_num   = ARRAY_SIZE(gpv8000_front_panel_characters),
+ 		.characters       = gpv8000_front_panel_characters
+		.text             = "GPV8000",
+	},
+};
+
+static struct gpio_keys_button dp2010_fp_gpio_keys_button =
+{
+	.code = KEY_SUSPEND,
+	.gpio = GPV8000_POWER_ON,
+	.desc = "Standby",
+};
+
+static struct platform_device gpv8000_fp_gpio_keys =
+{
+	.name          = "gpio-keys",
+	.id            = -1,
+	.num_resources = 0,
+	.dev           =
+	{
+		.platform_data = &(struct gpio_keys_platform_data)
+		{
+			.buttons  = &gpv8000_fp_gpio_keys_button,
+			.nbuttons = 1,
+		}
+	}
+};
+#endif
+/* NAND Flash */
+/* The GPV8000 main board is equipped with a 256 Mbyte AMD S34ML02G1 NAND flash memory */
+static struct stm_nand_bank_data gpv8000_nand_flash =
+ {
+	.csn		= 0,
+	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+	.nr_partitions	= 2,
+	.nr_partitions	= 9,
+	.partitions	= (struct mtd_partition [])
+	{
+		{
+			.name   = "boot",             // mtd0
+			.offset = 0x00000000,
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "kernel",           // mtd1
+			.offset = 0x00400000,         //   4 Mbyte
+			.size   = 0x00400000          //   4 Mbyte
+		},
+		{
+			.name   = "rootfs",           // mtd2 (UBI)
+			.offset = 0x00800000,         //   8 Mbyte
+			.size   = 0x0b600000          // 182 Mbyte
+		},
+		{
+			.name   = "logo",             // mtd3
+			.offset = 0x00180000,         // 1.5 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		},
+		{
+			.name   = "eeprom",           // mtd4
+			.offset = 0x00380000,         // 3.5 Mbyte
+			.size   = 0x00080000          // 512 kbyte
+		},
+		{
+			.name   = "config",           // mtd5 (UBI), seems to be here for compatibility reasons
+			.offset = 0x08000000,         // 128 Mbyte,  as it is somewhere in the middle of rootfs
+			.size   = 0x00100000          //   1 Mbyte
+		},
+		{
+			.name   = "user",             // mtd6
+			.offset = 0x0be00000,         // 190 Mbyte
+			.size   = 0x04000000          //  64 Mbyte
+		},
+		{
+			.name   = "ALL",              // mtd7
+			.offset = 0x00000000,         //   0 Mbyte
+			.size   = MTDPART_SIZ_FULL    // 256 Mbyte
+		},
+		{
+			.name   = "config1",          // mtd8
+			.offset = 0x0fe00000,         // 254 Mbyte
+			.size   = 0x00200000          //   2 Mbyte
+		}
+	},
+	.timing_spec            = &NAND_TSPEC_SPANSION_S34ML02G1
+};
+
+static int gpv8000_phy_reset(void *bus)
+{
+	/*
+	 * IC+ IP101 datasheet specifies 10mS low period and device usable
+	 * 2.5mS after rising edge. However experimentally it appears
+	 * 10mS is required for reliable functioning.
+	 */
+	gpio_set_value(GPV8000_GPIO_POWER_ON_ETH, 0);
+	mdelay(10);
+	gpio_set_value(GPV8000_GPIO_POWER_ON_ETH, 1);
+	mdelay(10);
+
+	return 1;
+}
+
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
+	.bus_id = 0,
+	.phy_reset = gpv8000_phy_reset,
+	.phy_mask = 0,
+	.probed_phy_irq = ILC_IRQ(25),  /* MDINT */
+};
+
+static struct platform_device *gpv8000_devices[] __initdata =
+{
+#if defined(CONFIG_LEDS_GPIO) \
+ || defined(CONFIG_LEDS_GPIO_MODULE)
+	&gpv8000_leds,
+#endif
+#if defined(INPUT_ET16315)
+	&gpv8000_keys,
+	&gpv8000_front_panel,
+ 	&gpv8000_fp_gpio_keys,
+#endif
+};
+
+static int __init device_init(void)
+{
+//	int i, j;
+
+	/* The "POWER_ON_ETH" line should be rather called "PHY_RESET",
+	 * but it isn't... ;-) */
+	gpio_request(GPV8000_GPIO_POWER_ON_ETH, "POWER_ON_ETH");
+	gpio_direction_output(GPV8000_GPIO_POWER_ON_ETH, 0);
+
+	gpio_request(GPV8000_POWER_ON, "POWER_ON");
+	gpio_direction_output(GPV8000_POWER_ON, 0);
+
+	gpio_request(DP2010_HDMI, "HDMI_HPD");  // stm_gpio(2.5)
+	gpio_direction_input(DP2010_HDMI);
+
+#if 0
+	/* Temporary: try and find the FP LED pio's */
+#define SLEEP 300
+	for (i = 4; i < 16; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+
+			if (j <> 2)
+			{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%2d,%1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+	stxh205_configure_ethernet(&(struct stxh205_ethernet_config)
+	{
+			.mode = stxh205_ethernet_mode_mii,
+			.ext_clk = 1,
+			.phy_bus = 0,
+			.phy_addr = -1,
+			.mdio_bus_data = &stmmac_mdio_bus,
+		});
+
+	/* PHY IRQ has to be triggered LOW */
+	set_irq_type(ILC_IRQ(25), IRQ_TYPE_LEVEL_LOW);
+
+#if 1  // SATA?
+	stxh205_configure_miphy(&(struct stxh205_miphy_config)
+	{
+		.mode  = SATA_MODE,
+		.iface = UPORT_IF,
+	});
+	stxh205_configure_sata();
+#endif
+	stxh205_configure_usb(0);
+
+	stxh205_configure_usb(1);
+
+	/*
+	 * Assignment of i2c pio's (order equals Fortis stock firmware setup)
+	 *
+	 * SSC1: FE/DEMOD
+	 * Becomes /dev/i2c-0
+	 * i2c addresses: 0x38 (STV6111 tuner), 0x68 (STV0913 demod)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(1), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc1.sclk = stxh205_ssc1_sclk_pio12_0,
+		.routing.ssc1.mtsr = stxh205_ssc1_mtsr_pio12_1
+	});
+	/*
+	 * SSC3: SYS
+	 * Becomes /dev/i2c-1
+	 * i2c addresses: none detected by i2cdetect
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(3), &(struct stxh205_ssc_config)
+	{
+		.routing.ssc3.sclk = stxh205_ssc3_sclk_pio15_5,
+		.routing.ssc3.mtsr = stxh205_ssc3_mtsr_pio15_6
+	});
+	/*
+	 * SSC0: HDMI
+	 * Becomes /dev/i2c-2
+	 * i2c addresses: 0x3a, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 (EEPROM?)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(0), &(struct stxh205_ssc_config)
+	{  // HDMI PIO SCDL:6.2, SDA:6.3
+		.routing.ssc0.sclk = stxh205_ssc0_sclk_pio6_2,
+		.routing.ssc0.mtsr = stxh205_ssc0_mtsr_pio6_3
+	});
+	/*
+	 * SSC2: LNBH25PQR LNB power driver
+	 * Becomes /dev/i2c-3
+	 * i2c address: 0x08
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(2), &(struct stxh205_ssc_config)
+	{  // LNB PIO SCDL:9.4, SDA:9.5
+		.routing.ssc2.sclk = stxh205_ssc2_sclk_pio9_4,
+		.routing.ssc2.mtsr = stxh205_ssc2_mtsr_pio9_5
+	});	stxh205_configure_ssc_i2c(STXH205_SSC(11), NULL);
+
+#if 0
+	/*
+	 * SSC5: ET6226 front panel driver
+	 * Becomes /dev/i2c-4
+	 * i2c addresses: 0x24(CTL), 0x27(KEYS), 0x34(DSP0), 0x35(DSP1), 0x36(DSP2), 0x37(DSP3)
+	 */
+	stxh205_configure_ssc_i2c(STXH205_SSC(5), &(struct stxh205_ssc_config)
+	{  // ET6226 PIO SCDL:2.6, SDA:2.7
+	});
+#endif
+
+#if defined(CONFIG_LIRC_SUPPORT)
+	stxh205_configure_lirc(&(struct stxh205_lirc_config)
+	{
+#ifdef CONFIG_LIRC_STM_UHF
+			.rx_mode = stxh205_lirc_rx_mode_uhf, });
+#else
+			.rx_mode = stxh205_lirc_rx_mode_ir,
+#endif
+		.tx_enabled    = 0,
+		.tx_od_enabled = 0,
+	});
+#endif  // CONFIG_LIRC_SUPPORT
+	stxh205_configure_pwm(&(struct stxh205_pwm_config)
+	{
+		/*
+		 * PWM10 is connected to 12V->1.2V power supply
+		 * for "debug purposes". Enable at your own risk!
+		 */
+		.out10_enabled = 0
+	});
+
+	stxh205_configure_mmc(&(struct stxh205_mmc_config)
+	{
+		.emmc = 0,
+		.no_mmc_boot_data_error = 1,
+	});
+
+	stxh205_configure_nand(&(struct stm_nand_config)
+	{
+		.driver             = stm_nand_flex,
+		.nr_banks           = 1,
+		.banks              = &gpv8000_nand_flash,
+		.rbn.flex_connected = 1,
+//		.bch_ecc_cfg        = BCH_ECC_CFG_NOECC
+	});
+
+	return platform_add_devices(gpv8000_devices, ARRAY_SIZE(gpv8000_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *gpv8000_ioport_map(unsigned long port, unsigned int size)
+{
+	/* If we have PCI then this should never be called because we
+	 * are using the generic iomap implementation. If we don't
+	 * have PCI then there are no IO mapped devices, so it still
+	 * shouldn't be called. */
+	BUG();
+	return NULL;
+}
+
+struct sh_machine_vector mv_gpv8000 __initmv =
+{
+	.mv_name = "gpv8000",
+	.mv_setup = gpv8000_setup,
+	.mv_nr_irqs = NR_IRQS,
+	.mv_ioport_map = gpv8000_ioport_map,
+};
+
+#if defined(CONFIG_HIBERNATION_ON_MEMORY)
+
+#include "../../kernel/cpu/sh4/stm_hom.h"
+
+static int gpv8000_board_freeze(struct stm_wakeup_devices *wkd)
+{
+	if (!wkd->stm_mac0_can_wakeup)
+	{
+		gpio_set_value(GPV8000_GPIO_POWER_ON_ETH, 0);
+	}
+	return 0;
+}
+
+static int gpv8000_board_defrost(struct stm_wakeup_devices *wkd)
+{
+	gpv8000_phy_reset(NULL);
+	return 0;
+}
+
+static struct stm_hom_board gpv8000_hom =
+{
+	.freeze  = gpv8000_board_freeze,
+	.restore = gpv8000_board_defrost,
+};
+
+static int __init gpv8000_hom_register(void)
+{
+	return stm_hom_board_register(&gpv8000_hom);
+}
+
+module_init(gpv8000_hom_register);
+#endif
+// vim:ts=4
--- a/arch/sh/Makefile.orig
+++ b/arch/sh/Makefile
@@ -204,6 +204,16 @@
 machdir-$(CONFIG_SH_ST_MB839)			+= mach-mb839
 machdir-$(CONFIG_SH_ST_MB903)			+= mach-mb903
 
+# Fortis boards
+machdir-$(CONFIG_SH_FORTIS_DP2010)		+= mach-dp2010
+machdir-$(CONFIG_SH_FORTIS_DP7000)		+= mach-dp7000
+machdir-$(CONFIG_SH_FORTIS_DP7001)		+= mach-dp7001
+machdir-$(CONFIG_SH_FORTIS_DP7050)		+= mach-dp7050
+machdir-$(CONFIG_SH_FORTIS_EP8000)		+= mach-ep8000
+machdir-$(CONFIG_SH_FORTIS_EPP8000)		+= mach-epp8000
+machdir-$(CONFIG_SH_FORTIS_FX6010)		+= mach-fx6010
+machdir-$(CONFIG_SH_FORTIS_GPV8000)		+= mach-gpv8000
+
 ifneq ($(machdir-y),)
 core-y	+= $(addprefix arch/sh/boards/, \
 	     $(filter-out ., $(patsubst %,%/,$(machdir-y))))
